<!DOCTYPE html>
<html lang="th">

<head>
    <meta charset="utf-8" />
    <title>Krit's Portfolio</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            overflow: hidden;
            background-image: url('https://i.pinimg.com/1200x/87/86/4a/87864a08e7ba6602314bd223548b3ac2.jpg');
            background-size: cover;
            background-position: center;
        }

        canvas {
            display: block
        }

        .fadeInOut {
            animation: fadeInOutAnimation 0.5s ease-in-out forwards
        }

        @keyframes fadeInOutAnimation {
            from {
                opacity: 0;
            }

            to {
                opacity: 100;
            }
        }

        .slideInDialog {
            animation: slideInDialogAnimation 0.5s ease-in-out forwards
        }

        @keyframes slideInDialogAnimation {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }

            to {
                transform: translateX(0px);
                opacity: 100;
            }
        }

        .slideIn {
            animation: slideInAnimation 1s ease-in-out forwards
        }

        @keyframes slideInAnimation {
            0% {
                opacity: 0;
                transform: translateX(-20px);
            }

            50% {
                opacity: 50;
                transform: translateX(-10px);
            }

            100% {
                opacity: 100;
                transform: translateX(0px);
            }
        }

        .slideOut {
            animation: slideOutAnimation 0.5s ease-in-out forwards;
        }

        @keyframes slideOutAnimation {
            from {
                opacity: 100;
                transform: translateX(0px);
            }

            to {
                opacity: 0;
                transform: translateX(20px);
            }
        }

        .myquestion {
            transition: 0.3s ease-out;
        }

        .myquestion:hover {
            font-size: 23px;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/RGBELoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

</head>

<body>
    <div id="loading-screen" style="
  position: fixed;
  inset: 0;
  background-color: black;
  color: white;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  z-index: 9999;
">
        <h1 style="font-size: 2rem;">Loading...</h1>
        <div id="progress-bar" style="
    width: 60%;
    height: 10px;
    background-color: #333;
    margin-top: 20px;
    border-radius: 5px;
    overflow: hidden;
  ">
            <div id="progress" style="
      width: 0%;
      height: 100%;
      background-color: gold;
      transition: width 0.3s ease;
    "></div>
        </div>
        <br>
        <div>
            ‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÅ‡∏£‡∏Å‡∏≠‡∏≤‡∏à‡∏à‡∏∞‡∏ô‡∏≤‡∏ô‡∏ô‡∏¥‡∏î‡∏ô‡∏∂‡∏á‡∏ô‡∏∞‡∏Ñ‡∏£‡∏±‡∏ö
        </div>
        <div>
            ‡πÄ‡∏•‡πà‡∏ô wordle ‡∏£‡∏≠‡πÑ‡∏õ‡∏Å‡πà‡∏≠‡∏ô‡∏ô‡πâ‡∏≤ üëâ <a href="https://www.nytimes.com/games/wordle/index.html" target="_blank">https://www.nytimes.com/games/wordle/index.html</a>
        </div>
    </div>

    <!-- <h1 id="status" style="color: white; position: absolute;">Lock: on</h1> -->
    <h1 id="welcome"
        style="position: absolute; top: 60%; right: 47%; font-size: 200px; color: red; pointer-events: none;">Welcome!
    </h1>
    <div id="boxDialog"
        style="position: absolute; color: white; left: 10%; top: 30%; display: none; height: 400px; pointer-events: none;">
        <img src="https://images.stockcake.com/public/9/0/0/900ca585-62ce-44f5-8345-85faaa60a0b0_large/amused-monkey-face-stockcake.jpg"
            alt="not found">
    </div>
    <div id="PBRDialog"
        style="position: absolute; color: white; left: 5%; top: 10%; display: none; flex-direction: column;">
        <h3>
            <span style="color: red">PBR</span> (<span style="font-style: italic;">Physically Based Rendering</span>)
            ‡∏Ñ‡∏∑‡∏≠‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏ô‡πÄ‡∏î‡∏≠‡∏£‡πå‡πÉ‡∏´‡πâ‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏î‡∏π‡∏™‡∏°‡∏à‡∏£‡∏¥‡∏á‡πÇ‡∏î‡∏¢‡∏à‡∏≥‡∏•‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏™‡∏∞‡∏ó‡πâ‡∏≠‡∏ô‡πÅ‡∏™‡∏á‡∏ï‡∏≤‡∏°‡∏Ñ‡∏∏‡∏ì‡∏™‡∏°‡∏ö‡∏±‡∏ï‡∏¥‡∏Ç‡∏≠‡∏á‡∏ß‡∏±‡∏™‡∏î‡∏∏
        </h3>
        <h3>
            ‡πÄ‡∏ä‡πà‡∏ô Albedo ‡∏™‡∏µ‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô, Metallic ‡∏£‡∏∞‡∏ö‡∏∏‡πÇ‡∏•‡∏´‡∏∞, Roughness ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡∏µ‡∏¢‡∏ö/‡∏´‡∏¢‡∏≤‡∏ö, ‡πÅ‡∏•‡∏∞‡πÉ‡∏ä‡πâ Normal Map ‡∏Å‡∏±‡∏ö Ambient Occlusion
            ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡πÅ‡∏•‡∏∞‡∏°‡∏¥‡∏ï‡∏¥‡∏Ç‡∏≠‡∏á‡∏û‡∏∑‡πâ‡∏ô‡∏ú‡∏¥‡∏ß
        </h3>
    </div>
    <div id="CelShadingDialog"
        style="position: absolute; color: white; left: 5%; top: 10%; display: none; flex-direction: column;">
        <h3>
            <span style="color: green">Cel Shading</span> ‡∏Ñ‡∏∑‡∏≠‡πÄ‡∏ó‡∏Ñ‡∏ô‡∏¥‡∏Ñ‡πÄ‡∏£‡∏ô‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏™‡πÑ‡∏ï‡∏•‡πå‡∏Å‡∏≤‡∏£‡πå‡∏ï‡∏π‡∏ô
            ‡πÉ‡∏´‡πâ‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏î‡∏π‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏ñ‡∏π‡∏Å‡∏ß‡∏≤‡∏î‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏™‡πâ‡∏ô‡πÅ‡∏•‡∏∞‡∏™‡∏µ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö
            ‡πÉ‡∏ä‡πâ‡∏Å‡∏≤‡∏£‡πÅ‡∏ö‡πà‡∏á‡πÇ‡∏ó‡∏ô‡∏™‡∏µ‡πÅ‡∏•‡∏∞‡∏Ç‡∏≠‡∏ö‡πÄ‡∏Ç‡∏ï‡πÄ‡∏á‡∏≤‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô ‡πÅ‡∏ó‡∏ô‡∏Å‡∏≤‡∏£‡πÑ‡∏•‡πà‡∏™‡∏µ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÇ‡∏•‡∏Å‡∏à‡∏£‡∏¥‡∏á
        </h3>
        <h3>
            ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÇ‡∏î‡∏¢‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏°‡∏∏‡∏°‡∏Ç‡∏≠‡∏á‡πÅ‡∏™‡∏á‡∏Å‡∏±‡∏ö‡∏û‡∏∑‡πâ‡∏ô‡∏ú‡∏¥‡∏ß ‡πÅ‡∏¢‡∏Å‡πÄ‡∏õ‡πá‡∏ô‡πÇ‡∏ó‡∏ô‡∏™‡∏µ‡∏ï‡πà‡∏≤‡∏á ‡πÜ ‡πÅ‡∏•‡∏∞‡∏ß‡∏≤‡∏î‡πÄ‡∏™‡πâ‡∏ô‡∏Ç‡∏≠‡∏ö‡∏£‡∏≠‡∏ö‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡πÑ‡∏ï‡∏•‡πå‡∏Å‡∏≤‡∏£‡πå‡∏ï‡∏π‡∏ô
        </h3>
    </div>
    <div id="VertexShaderDialog"
        style="position: absolute; color: white; left: 5%; top: 10%; display: none; flex-direction: column;">
        <h3>
            <span style="color: blue">Vertex Shader</span> ‡∏Ñ‡∏∑‡∏≠‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ô‡∏ö‡∏ô GPU
            ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÅ‡∏•‡∏∞‡∏Ñ‡∏∏‡∏ì‡∏™‡∏°‡∏ö‡∏±‡∏ï‡∏¥‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏à‡∏∏‡∏î (<span style="font-style: italic;">vertex</span>) ‡∏Ç‡∏≠‡∏á‡πÇ‡∏°‡πÄ‡∏î‡∏• <span
                style="font-weight: bold;">3D</span>
        </h3>
        <h3>
            ‡πÉ‡∏ä‡πâ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà ‡∏´‡∏°‡∏∏‡∏ô ‡∏Ç‡∏¢‡∏≤‡∏¢ ‡∏´‡∏£‡∏∑‡∏≠‡∏ö‡∏¥‡∏î‡πÄ‡∏ö‡∏∑‡∏≠‡∏ô‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏ ‡πÅ‡∏•‡∏∞‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡πâ Pixel Shader ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏ô‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏™‡∏µ‡πÅ‡∏•‡∏∞‡πÅ‡∏™‡∏á
        </h3>
    </div>
    <div id="theManDialog"
        style="position: absolute; color: white; left: 60%; top: 35%; display: none; flex-direction: column;">
        <h2 id="ansQuestion" style="color: red; pointer-events: none;">‡∏≠‡∏¢‡∏≤‡∏Å‡∏à‡∏∞‡∏ñ‡∏≤‡∏°‡∏≠‡∏∞‡πÑ‡∏£‡πÑ‡∏´‡∏°‡∏Ñ‡∏£‡∏±‡∏ö.</h2>
        <!-- <h3 id="myname" class="myquestion" style="cursor: pointer;" onclick="answer('myname')">
            > ‡∏Ñ‡∏∏‡∏ì‡πÄ‡∏õ‡πá‡∏ô‡πÉ‡∏Ñ‡∏£?
        </h3> -->
        <h3 id="descMySelf" class="myquestion" style="cursor: pointer;" onclick="answer('descMySelf')">
            > ‡∏Ç‡∏≠‡∏î‡∏π‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ñ‡∏∏‡∏ì‡∏ä‡∏±‡∏î‡πÜ‡∏´‡∏ô‡πà‡∏≠‡∏¢
        </h3>
        <h3 id="myage" class="myquestion" style="cursor: pointer;" onclick="answer('myage')">
            > ‡∏Ñ‡∏∏‡∏ì‡∏≠‡∏≤‡∏¢‡∏∏‡πÄ‡∏ó‡πà‡∏≤‡πÑ‡∏´‡∏£‡πà?
        </h3>
        <h3 id="mywork" class="myquestion" style="cursor: pointer; color: green;" onclick="answer('mywork')">
            > ‡∏á‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á‡∏â‡∏±‡∏ô
        </h3>
        <h3 id="credits" class="myquestion" style="cursor: pointer; color:black" onclick="answer('credits')">
            > ‡πÄ‡∏Ñ‡∏£‡∏î‡∏¥‡∏ï
        </h3>
        <h3 id="descMySelf_q_1" class="myquestion" style="cursor: pointer; display: none;"
            onclick="answer('descMySelf_q_1')">
            > ‡πÄ‡∏ó‡πà‡∏°‡∏≤‡∏Å!
        </h3>
    </div>
    <div id="creditDialog"
        style="position: absolute; color: white; bottom: 0%; right: 43%; display: none; flex-direction: column; background-color: black; padding: 5px; border-radius: 10px; margin-bottom: 5px;">
        <h5>
            ‡∏Å‡∏î‡∏ó‡∏µ‡πà <span style="font-style: italic;">‡∏ä‡∏∑‡πà‡∏≠</span> ‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô‡πÇ‡∏°‡πÄ‡∏î‡∏•‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡πÅ‡∏´‡∏•‡πà‡∏á‡∏ó‡∏µ‡πà‡∏°‡∏≤
        </h5>
        <h5>
            <span style="color: red">ESC</span> ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏Ñ‡∏∏‡∏¢‡∏Å‡∏±‡∏ö‡∏ú‡∏°
        </h5>
    </div>
    <script>
        (() => {
            const manager = new THREE.LoadingManager();
            const progressBar = document.getElementById("progress");
            const loadingScreen = document.getElementById("loading-screen");
            // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï progress bar
            manager.onProgress = (url, itemsLoaded, itemsTotal) => {
                const progress = (itemsLoaded / itemsTotal) * 100;
                progressBar.style.width = `${progress}%`;
            };

            // ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÇ‡∏´‡∏•‡∏î‡∏Ñ‡∏£‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
            manager.onLoad = () => {
                loadingScreen.style.transition = "opacity 0.8s ease";
                loadingScreen.style.opacity = "0";
                setTimeout(() => { loadingScreen.remove(); fadeInModel(myInfo, 1000); fadeInModel(myPic, 1000) }, 800);
            };

            // ‡πÉ‡∏ä‡πâ Loader ‡∏ó‡∏∏‡∏Å‡∏ï‡∏±‡∏ß‡∏ú‡πà‡∏≤‡∏ô manager
            const loaderBase = new THREE.GLTFLoader(manager);
            const loaderInfo = new THREE.GLTFLoader(manager);
            const loaderTheman = new THREE.GLTFLoader(manager);
            const loaderNextPBR = new THREE.GLTFLoader(manager);
            const loaderBackPBR = new THREE.GLTFLoader(manager);
            const loaderNextCel = new THREE.GLTFLoader(manager);
            const loaderBackCel = new THREE.GLTFLoader(manager);
            const loaderTable1 = new THREE.GLTFLoader(manager);
            const loaderTable2 = new THREE.GLTFLoader(manager);
            const loaderTable3 = new THREE.GLTFLoader(manager);
            const loaderPBRTitle = new THREE.GLTFLoader(manager);
            const loaderCelTitle = new THREE.GLTFLoader(manager);
            const loaderVertexTitle = new THREE.GLTFLoader(manager);
            const loaderBackVertex = new THREE.GLTFLoader(manager);
            const loaderDice = new THREE.GLTFLoader(manager);
            const loaderCredits = new THREE.GLTFLoader(manager);
            const loaderThemanCredit = new THREE.GLTFLoader(manager);
            const loaderDiceCredit = new THREE.GLTFLoader(manager);
            const loaderBaseCredit = new THREE.GLTFLoader(manager);
            const loaderHeightmapCredit = new THREE.GLTFLoader(manager);
            // GLTF model
            // const loaderBase = new THREE.GLTFLoader();
            loaderBase.load(
                "https://krttphs.github.io/Portfolio/base.glb",
                gltf => {
                    const model = gltf.scene;
                    model.position.set(0, 0, 0);
                    gltf.scene.traverse(node => {
                        if (node.isMesh) {
                            node.castShadow = false;      // ‡πÉ‡∏´‡πâ‡∏™‡πà‡∏á‡πÄ‡∏á‡∏≤‡πÑ‡∏î‡πâ
                            node.receiveShadow = true;   // ‡πÉ‡∏´‡πâ‡∏£‡∏±‡∏ö‡πÄ‡∏á‡∏≤‡πÑ‡∏î‡πâ
                            // ‡∏ñ‡πâ‡∏≤ material ‡πÑ‡∏°‡πà‡∏ï‡∏≠‡∏ö‡∏™‡∏ô‡∏≠‡∏á‡πÅ‡∏™‡∏á ‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô MeshStandardMaterial
                            if (!(node.material instanceof THREE.MeshStandardMaterial)) {
                                node.material = new THREE.MeshStandardMaterial({
                                    map: node.material.map || null,
                                    roughness: 0.5,
                                    metalness: 0
                                });
                            }
                        }
                    });
                    scene.add(model);
                }
            );
            loaderCredits.load(
                "https://krttphs.github.io/Portfolio/theman/credits.glb",
                gltf => {
                    const model = gltf.scene;
                    model.position.set(0, 0, 0);
                    gltf.scene.traverse(node => {
                        if (node.isMesh) {
                            node.material.side = THREE.DoubleSide;
                            node.castShadow = true;
                            node.receiveShadow = false;
                            const mat = node.material;
                            mat.transparent = false;
                            mat.depthWrite = true;
                            mat.depthTest = true;
                            mat.alphaTest = 0.5; // ‡∏Å‡∏±‡∏ô‡∏û‡∏¥‡∏Å‡πÄ‡∏ã‡∏•‡πÇ‡∏õ‡∏£‡πà‡∏á‡πÉ‡∏™
                            mat.needsUpdate = true;
                        }
                    });
                    scene.add(model);
                }
            );
            let goToThemanCredit
            let goToDiceCredit
            let goToBaseCredit
            let goToHeightmapCredit

            loaderHeightmapCredit.load("https://krttphs.github.io/Portfolio/theman/heightmapCredit.glb",
                gltf => {
                    const model = gltf.scene;
                    model.name = "goToHeightmapCredit";
                    goToHeightmapCredit = model

                    gltf.scene.traverse(node => {
                        if (node.isMesh) {
                            node.userData.parentType = "goToHeightmapCredit";
                            node.castShadow = true;
                            node.receiveShadow = true;
                        }
                    });
                    scene.add(model)
                }
            )
            loaderThemanCredit.load("https://krttphs.github.io/Portfolio/theman/themanCredit.glb",
                gltf => {
                    const model = gltf.scene;
                    model.name = "goToThemanCredit";
                    goToThemanCredit = model

                    gltf.scene.traverse(node => {
                        if (node.isMesh) {
                            node.userData.parentType = "goToThemanCredit";
                            node.castShadow = true;
                            node.receiveShadow = true;
                        }
                    });
                    scene.add(model)
                }
            )
            loaderDiceCredit.load("https://krttphs.github.io/Portfolio/theman/diceCredit.glb",
                gltf => {
                    const model = gltf.scene;
                    model.name = "goToDiceCredit";
                    goToDiceCredit = model

                    gltf.scene.traverse(node => {
                        if (node.isMesh) {
                            node.userData.parentType = "goToDiceCredit";
                            node.castShadow = true;
                            node.receiveShadow = true;
                        }
                    });
                    scene.add(model)
                }
            )
            loaderBaseCredit.load("https://krttphs.github.io/Portfolio/theman/baseCredit.glb",
                gltf => {
                    const model = gltf.scene;
                    model.name = "goToBaseCredit";

                    goToBaseCredit = model

                    gltf.scene.traverse(node => {
                        if (node.isMesh) {
                            node.userData.parentType = "goToBaseCredit";
                            node.castShadow = true;
                            node.receiveShadow = true;
                        }
                    });
                    scene.add(model)
                }
            )


            let dice_mesh
            loaderDice.load("https://krttphs.github.io/Portfolio/theman/dice_model.glb",
                gltf => {
                    const model = gltf.scene;
                    model.scale.set(0.1, 0.1, 0.1);
                    model.position.set(0, 0.5, 2)
                    model.traverse((node) => {
                        if (node.isMesh && !dice_mesh) {
                            dice_mesh = node; // ‡πÄ‡∏Å‡πá‡∏ö Mesh ‡πÅ‡∏ó‡∏ô Group
                        }
                        if (node.isMesh) {
                            node.material = new THREE.ShaderMaterial({
                                vertexShader: vert,
                                fragmentShader: frag,
                                uniforms: uniforms,
                                transparent: node.material.transparent || false
                            });
                            node.castShadow = true;
                        }
                    });
                    scene.add(model);
                }
            );
            let myInfo;
            // const loaderInfo = new THREE.GLTFLoader();
            loaderInfo.load(
                "https://krttphs.github.io/Portfolio/theman/myinfo.glb",
                gltf => {
                    myInfo = gltf.scene;
                    myInfo.position.set(0, 0.2, 0);
                    gltf.scene.traverse(node => {
                        if (node.isMesh) {
                            const mat = node.material
                            if (!(mat instanceof THREE.MeshStandardMaterial)) {
                                node.material = new THREE.MeshStandardMaterial({
                                    map: mat.map || null,
                                    color: mat.color || 0xffffff,
                                    roughness: 0.5,
                                    metalness: 0,
                                    transparent: true,
                                    opacity: 0
                                });
                            } else {
                                // ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô MeshStandardMaterial ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß ‡∏õ‡∏£‡∏±‡∏ö‡πÄ‡∏â‡∏û‡∏≤‡∏∞ property
                                mat.roughness = 0.5;
                                mat.metalness = 0;
                            }
                            node.castShadow = true;
                            node.receiveShadow = false;
                            node.material.transparent = true;
                            node.material.opacity = 0;
                        }
                    });
                    scene.add(myInfo);
                }
            );
            let myPic;
            const img = new Image();
            img.src = 'https://krttphs.github.io/Portfolio/theman/kritpic.jpg';
            img.onload = () => {
                const aspect = img.height / img.width;
                const geometry = new THREE.PlaneGeometry(1, 1 * aspect);
                const texture = new THREE.TextureLoader().load(img.src);
                const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, roughness: 0.5, metalness: 0, transparent: true, opacity: 0 });
                const plane = new THREE.Mesh(geometry, material);
                plane.rotation.y = Math.PI / 2
                plane.position.set(4.8, 1, -0.8);
                myPic = plane
                plane.castShadow = true;
                scene.add(plane);
            };

            const clock = new THREE.Clock();
            let mixer;
            let theMan;
            // const loaderTheman = new THREE.GLTFLoader();
            loaderTheman.load(
                "https://krttphs.github.io/Portfolio/theman/the_man_sitting.glb",
                gltf => {
                    const model = gltf.scene;
                    model.position.set(4.5, 0, 0);
                    theMan = model
                    // ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô animation
                    mixer = new THREE.AnimationMixer(model);
                    gltf.animations.forEach(clip => {
                        mixer.clipAction(clip).play();
                    });

                    gltf.scene.traverse(node => {
                        if (node.isMesh) {
                            const mat = node.material;
                            mat.transparent = false;
                            mat.depthWrite = true;
                            mat.depthTest = true;
                            mat.alphaTest = 0.5; // ‡∏Å‡∏±‡∏ô‡∏û‡∏¥‡∏Å‡πÄ‡∏ã‡∏•‡πÇ‡∏õ‡∏£‡πà‡∏á‡πÉ‡∏™
                            mat.needsUpdate = true;
                        }
                    });
                    scene.add(model);
                }

            );
            let nextBtnPBR;
            loaderNextPBR.load("https://krttphs.github.io/Portfolio/theman/next.glb",
                gltf => {
                    const model = gltf.scene;
                    model.name = "nextBtnPBR";
                    model.position.set(1.7, 0.2, 2)
                    model.scale.set(0.2, 0.2, 0.2);
                    nextBtnPBR = model
                    gltf.scene.traverse(node => {
                        if (node.isMesh) {
                            node.userData.parentType = "nextBtnPBR";
                            node.lookAt(new THREE.Vector3(1, 0.7, 1));
                            node.rotation.x = Math.PI / 2;
                            node.material.transparent = true;
                            node.material.opacity = 0;
                        }
                        node.castShadow = true;
                    });
                    scene.add(model)
                }
            )
            let backBtnPBR;
            loaderBackPBR.load("https://krttphs.github.io/Portfolio/theman/back.glb",
                gltf => {
                    const model = gltf.scene;
                    model.name = "backBtnPBR";
                    model.position.set(2.7, 0.2, 2)
                    model.scale.set(0.2, 0.1, 0.2);
                    backBtnPBR = model
                    gltf.scene.traverse(node => {
                        if (node.isMesh) {
                            node.userData.parentType = "backBtnPBR";
                            node.lookAt(new THREE.Vector3(3, 0.7, 1));
                            node.rotation.x = Math.PI / 2;
                            node.material.transparent = true;
                            node.material.opacity = 0;
                        }
                    });
                    scene.add(model)
                }
            )
            let nextBtnCel;
            loaderNextCel.load("https://krttphs.github.io/Portfolio/theman/next.glb",
                gltf => {
                    const model = gltf.scene;
                    model.name = "nextBtnCel";
                    model.position.set(-0.3, 0.2, 2)
                    model.scale.set(0.2, 0.2, 0.2);
                    nextBtnCel = model

                    gltf.scene.traverse(node => {
                        if (node.isMesh) {
                            node.userData.parentType = "nextBtnCel";
                            const dir = new THREE.Vector3();
                            dir.subVectors(new THREE.Vector3(0, 0.5, 1), node.getWorldPosition(new THREE.Vector3()));
                            dir.y = 0;
                            node.lookAt(node.position.clone().add(dir));
                            node.rotation.x = Math.PI / 2;
                            node.material.transparent = true;
                            node.material.opacity = 0;
                        }
                    });
                    scene.add(model)
                }
            )
            let backBtnCel;
            loaderBackCel.load("https://krttphs.github.io/Portfolio/theman/back.glb",
                gltf => {
                    const model = gltf.scene;
                    model.name = "backBtnCel";
                    model.position.set(0.6, 0.2, 2)
                    model.scale.set(0.2, 0.1, 0.2);
                    backBtnCel = model
                    gltf.scene.traverse(node => {
                        if (node.isMesh) {
                            node.userData.parentType = "backBtnCel";
                            const dir = new THREE.Vector3();
                            dir.subVectors(new THREE.Vector3(0, 0.5, 1), node.getWorldPosition(new THREE.Vector3()));
                            dir.y = 0;
                            node.lookAt(node.position.clone().add(dir));
                            node.rotation.x = Math.PI / 2;
                            node.material.transparent = true;
                            node.material.opacity = 0;
                        }
                    });
                    scene.add(model)
                }
            )
            let backBtnVertex;
            loaderBackVertex.load("https://krttphs.github.io/Portfolio/theman/back.glb",
                gltf => {
                    const model = gltf.scene;
                    model.name = "backBtnCel";
                    model.position.set(-1.3, 0.2, 2)
                    model.scale.set(0.2, 0.1, 0.2);
                    backBtnVertex = model
                    gltf.scene.traverse(node => {
                        if (node.isMesh) {
                            node.userData.parentType = "backBtnVertex";
                            const dir = new THREE.Vector3();
                            dir.subVectors(new THREE.Vector3(-3, 1, 1), node.getWorldPosition(new THREE.Vector3()));
                            dir.y = 0;
                            node.lookAt(node.position.clone().add(dir));
                            node.rotation.x = Math.PI / 2;
                            node.material.transparent = true;
                            node.material.opacity = 0;
                        }
                    });
                    scene.add(model)
                }
            )
            let spotLight1;
            loaderTable1.load("https://krttphs.github.io/Portfolio/theman/table.glb",
                gltf => {
                    const model = gltf.scene;
                    model.position.set(2, 0.1, 2)
                    model.scale.set(0.2, 0.1, 0.2);
                    scene.add(model)
                    // ‡∏™‡∏£‡πâ‡∏≤‡∏á SpotLight ‡πÉ‡∏´‡πâ‡∏™‡πà‡∏≠‡∏á‡∏à‡∏≤‡∏Å‡∏î‡πâ‡∏≤‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡πÇ‡∏ï‡πä‡∏∞ (z - 2)
                    const spotLight = new THREE.SpotLight(0xffffff, 5);
                    spotLight.position.set(model.position.x, model.position.y + 0.3, model.position.z - 2);

                    // ‡∏™‡∏£‡πâ‡∏≤‡∏á target ‡πÅ‡∏¢‡∏Å ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÑ‡∏ü‡∏™‡πà‡∏≠‡∏á‡πÑ‡∏õ‡∏ó‡∏µ‡πà‡πÇ‡∏ï‡πä‡∏∞
                    const targetObject = new THREE.Object3D();
                    targetObject.position.copy(model.position);
                    scene.add(targetObject);

                    // ‡∏ï‡∏±‡πâ‡∏á target ‡πÉ‡∏´‡πâ‡πÑ‡∏ü‡∏™‡πà‡∏≠‡∏á‡πÑ‡∏õ‡∏ó‡∏µ‡πà‡∏à‡∏∏‡∏î‡∏ô‡∏±‡πâ‡∏ô
                    spotLight.target = targetObject;

                    // ‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏∏‡∏ì‡∏™‡∏°‡∏ö‡∏±‡∏ï‡∏¥‡∏Ç‡∏≠‡∏á‡πÅ‡∏™‡∏á
                    spotLight.angle = Math.PI / 8;
                    spotLight.penumbra = 0.4;
                    spotLight.distance = 10;
                    spotLight.decay = 2;
                    spotLight.visible = false
                    spotLight1 = spotLight
                    scene.add(spotLight);
                    // renderer.render(scene, camera);
                }
            )
            loaderPBRTitle.load("https://krttphs.github.io/Portfolio/theman/PBRTitle.glb",
                gltf => {
                    const model = gltf.scene;
                    model.position.set(2.13, 0.1, 1.79)
                    model.scale.set(0.05, 0.05, 0.05);
                    model.rotation.x = Math.PI / 2;
                    scene.add(model)
                }
            )
            let spotLight2
            loaderTable2.load("https://krttphs.github.io/Portfolio/theman/table.glb",
                gltf => {
                    const model = gltf.scene;
                    model.position.set(0, 0.1, 2)
                    model.scale.set(0.2, 0.1, 0.2);
                    scene.add(model)
                    // ‡∏™‡∏£‡πâ‡∏≤‡∏á SpotLight ‡πÉ‡∏´‡πâ‡∏™‡πà‡∏≠‡∏á‡∏à‡∏≤‡∏Å‡∏î‡πâ‡∏≤‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡πÇ‡∏ï‡πä‡∏∞ (z - 2)
                    const spotLight = new THREE.SpotLight(0xffffff, 5);
                    spotLight.position.set(model.position.x, model.position.y + 0.3, model.position.z - 2);

                    // ‡∏™‡∏£‡πâ‡∏≤‡∏á target ‡πÅ‡∏¢‡∏Å ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÑ‡∏ü‡∏™‡πà‡∏≠‡∏á‡πÑ‡∏õ‡∏ó‡∏µ‡πà‡πÇ‡∏ï‡πä‡∏∞
                    const targetObject = new THREE.Object3D();
                    targetObject.position.copy(model.position);
                    scene.add(targetObject);

                    // ‡∏ï‡∏±‡πâ‡∏á target ‡πÉ‡∏´‡πâ‡πÑ‡∏ü‡∏™‡πà‡∏≠‡∏á‡πÑ‡∏õ‡∏ó‡∏µ‡πà‡∏à‡∏∏‡∏î‡∏ô‡∏±‡πâ‡∏ô
                    spotLight.target = targetObject;

                    // ‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏∏‡∏ì‡∏™‡∏°‡∏ö‡∏±‡∏ï‡∏¥‡∏Ç‡∏≠‡∏á‡πÅ‡∏™‡∏á
                    spotLight.angle = Math.PI / 8;
                    spotLight.penumbra = 0.4;
                    spotLight.distance = 10;
                    spotLight.decay = 2;
                    spotLight.visible = false
                    spotLight2 = spotLight
                    scene.add(spotLight);
                    // renderer.render(scene, camera);
                }
            )
            loaderCelTitle.load("https://krttphs.github.io/Portfolio/theman/CelTitle.glb",
                gltf => {
                    const model = gltf.scene;
                    model.position.set(0.12, 0.1, 1.79)
                    model.scale.set(0.05, 0.05, 0.05);
                    model.rotation.x = Math.PI / 2;
                    model.rotation.z = Math.PI;
                    scene.add(model)
                }
            )
            let spotLight3
            loaderTable3.load("https://krttphs.github.io/Portfolio/theman/table.glb",
                gltf => {
                    const model = gltf.scene;
                    model.position.set(-2, 0.1, 2)
                    model.scale.set(0.2, 0.1, 0.2);
                    scene.add(model)
                    // ‡∏™‡∏£‡πâ‡∏≤‡∏á SpotLight ‡πÉ‡∏´‡πâ‡∏™‡πà‡∏≠‡∏á‡∏à‡∏≤‡∏Å‡∏î‡πâ‡∏≤‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡πÇ‡∏ï‡πä‡∏∞ (z - 2)
                    const spotLight = new THREE.SpotLight(0xffffff, 5);
                    spotLight.position.set(model.position.x, model.position.y + 0.3, model.position.z - 2);

                    // ‡∏™‡∏£‡πâ‡∏≤‡∏á target ‡πÅ‡∏¢‡∏Å ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÑ‡∏ü‡∏™‡πà‡∏≠‡∏á‡πÑ‡∏õ‡∏ó‡∏µ‡πà‡πÇ‡∏ï‡πä‡∏∞
                    const targetObject = new THREE.Object3D();
                    targetObject.position.copy(model.position);
                    scene.add(targetObject);

                    // ‡∏ï‡∏±‡πâ‡∏á target ‡πÉ‡∏´‡πâ‡πÑ‡∏ü‡∏™‡πà‡∏≠‡∏á‡πÑ‡∏õ‡∏ó‡∏µ‡πà‡∏à‡∏∏‡∏î‡∏ô‡∏±‡πâ‡∏ô
                    spotLight.target = targetObject;

                    // ‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏∏‡∏ì‡∏™‡∏°‡∏ö‡∏±‡∏ï‡∏¥‡∏Ç‡∏≠‡∏á‡πÅ‡∏™‡∏á
                    spotLight.angle = Math.PI / 8;
                    spotLight.penumbra = 0.4;
                    spotLight.distance = 10;
                    spotLight.decay = 2;
                    spotLight.visible = false
                    spotLight3 = spotLight
                    scene.add(spotLight);
                    // renderer.render(scene, camera);
                }
            )
            loaderVertexTitle.load("https://krttphs.github.io/Portfolio/theman/VertexTitle.glb",
                gltf => {
                    const model = gltf.scene;
                    model.position.set(-1.86, 0.1, 1.79)
                    model.scale.set(0.05, 0.05, 0.05);
                    model.rotation.x = Math.PI / 2;
                    model.rotation.z = Math.PI;
                    scene.add(model)
                }
            )
            // --- Scene / Camera / Renderer ---
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 100);

            camera.position.set(-3, 2, 0);

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(innerWidth, innerHeight);
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            renderer.shadowMap.enabled = true;

            document.body.appendChild(renderer.domElement);

            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 0.5, 0);
            controls.enableDamping = true;

            //PBR_Shader
            // --- ‡πÄ‡∏û‡∏¥‡πà‡∏° Sphere Material ---
            const cubeUrls = [
                'https://threejs.org/examples/textures/cube/Bridge2/posx.jpg',
                'https://threejs.org/examples/textures/cube/Bridge2/negx.jpg',
                'https://threejs.org/examples/textures/cube/Bridge2/posy.jpg',
                'https://threejs.org/examples/textures/cube/Bridge2/negy.jpg',
                'https://threejs.org/examples/textures/cube/Bridge2/posz.jpg',
                'https://threejs.org/examples/textures/cube/Bridge2/negz.jpg'
            ];
            const envMap = new THREE.CubeTextureLoader().load(cubeUrls);
            envMap.encoding = THREE.sRGBEncoding;
            scene.environment = envMap; // IBL
            const geo = new THREE.SphereBufferGeometry(0.2, 16, 16);
            const mat = new THREE.MeshStandardMaterial({
                color: 0x3b82f6,   // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏µ‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà
                metalness: 0.9,
                roughness: 0.1,
            });

            const cube = new THREE.Mesh(geo, mat);
            cube.position.set(2, 0.5, 2)
            scene.add(cube);

            //Cel Shader
            const uniforms = {
                uTime: { value: 0.0 },
                uLightPos: { value: new THREE.Vector3(0, 1, 0) },
                uCameraPos: { value: new THREE.Vector3() },
                uTex: { value: new THREE.TextureLoader().load('https://krttphs.github.io/Portfolio/textures/Material.001_baseColor.png') },
                uNormalMap: { value: new THREE.TextureLoader().load('https://krttphs.github.io/Portfolio/textures/Material.001_normal.png') }
            };

            const vert = `
                uniform float uTime;
                varying vec3 vNormal;
                varying vec3 vPosW;
                varying vec2 vUv;
                uniform sampler2D uTex;

                void main(){
                vNormal = normalize(mat3(modelMatrix) * normal);
                vec3 pos = position;
                vUv = uv;
                // pos.y += sin(pos.z*3.0*3.14+uTime*5.0)*0.1;
                vPosW   = ( modelMatrix * vec4(pos, 1.0)).xyz;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `;

            const frag = `
                precision mediump float;
                varying vec3 vNormal;
                uniform vec3 uLightPos;
                uniform vec3 uCameraPos;
                varying vec3 vPosW;
                varying vec2 vUv;
                uniform sampler2D uTex;
                uniform sampler2D uNormalMap;

                void main()
                {
                // ‡πÇ‡∏´‡∏•‡∏î normal map
                vec3 normalTex = texture2D(uNormalMap, vUv).rgb;
                // ‡πÅ‡∏õ‡∏•‡∏á‡∏à‡∏≤‡∏Å [0,1] -> [-1,1]
                normalTex = normalize(normalTex * 2.0 - 1.0);
                // ‡∏£‡∏ß‡∏° normal map ‡∏Å‡∏±‡∏ö normal ‡∏Ç‡∏≠‡∏á geometry
                vec3 finalNormal = normalize(vNormal + normalTex * 0.5); // 0.5 = strength ‡∏Ç‡∏≠‡∏á normal map
                
                vec3 lightDir = normalize(uLightPos - vPosW);
                float diffuse = clamp(dot(vNormal, lightDir), 0.0, 1.0);
                float levels = 4.0;           
                diffuse  = floor(diffuse * levels) / levels;
                diffuse += 0.5;

                vec3 R = reflect(-lightDir, vNormal);
                vec3 V = normalize(uCameraPos - vPosW);
                float specular = max( pow( dot(R,V), 8.0 ) , 0.0);

                // specular = step(0.5, specular);
                specular = smoothstep(0.4,0.6,specular);

                if(diffuse <= 0.6)
                    specular = 0.0;

                vec3 base  = texture2D(uTex ,vUv).rgb;        
                vec3 color = (base * diffuse) + vec3(specular);

                gl_FragColor = vec4(color, 1.0);
                }
            `;

            // const cel_geo = new THREE.TorusBufferGeometry(0.2, 0.1, 16, 16);
            // const cel_geo = new THREE.IcosahedronGeometry(0.2, 1);
            // const geo = new THREE.SphereBufferGeometry(1, 200, 200);
            //const geo = new THREE.PlaneBufferGeometry(2.0, 2.0, 20, 20);
            // const cel_mat = new THREE.ShaderMaterial({
            //     vertexShader: vert,
            //     fragmentShader: frag,
            //     uniforms,
            //     //wireframe: true
            // });
            // const cel_mesh = new THREE.Mesh(cel_geo, cel_mat);
            // cel_mesh.position.set(0, 0.5, 2);

            // scene.add(cel_mesh);

            //Vertex shader
            const mapUniforms = {
                uTime: { value: 0.0 },
                uHeight: { value: null } // texture ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÇ‡∏´‡∏•‡∏î‡∏°‡∏≤
            };
            const mapVert = `
    uniform sampler2D uHeight;
    uniform float uTime;

    varying float vH;

    void main(){
      vec3 pos = position;
      float h = texture2D(uHeight, uv).r;
      float offset = sin(uTime + h * 5.0) * 0.2;
      pos.z += h * 2.0 + offset;   // ‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤‡∏ô‡∏µ‡πâ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏°/‡∏•‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ô‡∏π‡∏ô
      vH = h;                             
      gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
    }
  `;
            const mapFrag = `
    precision mediump float;
    varying float vH;
    void main(){
    vec3 lowColor = vec3(0.0, 0.0, 1.0);   // ‡∏ô‡πâ‡∏≥‡πÄ‡∏á‡∏¥‡∏ô
    vec3 highColor = vec3(1.0, 0.0, 0.0);  // ‡πÅ‡∏î‡∏á
    vec3 color = mix(lowColor, highColor, vH);
    gl_FragColor = vec4(color, 1.0);
  }
  `;

            new THREE.TextureLoader().load('https://krttphs.github.io/Portfolio/thailand_heightmap.png', (tex) => {
                mapUniforms.uHeight.value = tex;
            });
            const map_geo = new THREE.PlaneBufferGeometry(4, 5, 1000, 1000);
            const map_mat = new THREE.ShaderMaterial({
                vertexShader: mapVert,
                fragmentShader: mapFrag,
                uniforms: mapUniforms,
                //wireframe: true, // ‡πÄ‡∏õ‡∏¥‡∏î‡∏ñ‡πâ‡∏≤‡∏≠‡∏¢‡∏≤‡∏Å‡∏î‡∏π‡πÄ‡∏™‡πâ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á
                side: THREE.DoubleSide
            });
            const map_mesh = new THREE.Mesh(map_geo, map_mat);
            map_mesh.rotation.y = Math.PI
            map_mesh.scale.set(0.1, 0.1, 0.1)
            map_mesh.position.set(-2, 0.5, 2.1)
            scene.add(map_mesh);

            // --- Ground (‡πÄ‡∏™‡πâ‡∏ô‡∏Å‡∏£‡∏¥‡∏î‡∏ä‡πà‡∏ß‡∏¢‡∏Å‡∏∞‡∏£‡∏∞‡∏¢‡∏∞) ---
            // const grid = new THREE.GridHelper(10, 10, 0x666666, 0x333333);
            // grid.position.y = -0.001;
            // scene.add(grid);
            // const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            // dirLight.position.set(5, 10, 5);
            // scene.add(dirLight);

            const ptLight = new THREE.PointLight(0xfffffff, 1, 50);
            ptLight.position.set(0, 2, 0);
            ptLight.castShadow = true;
            ptLight.shadow.mapSize.width = 2048;
            ptLight.shadow.mapSize.height = 2048;
            scene.add(ptLight);

            // ‡∏™‡∏£‡πâ‡∏≤‡∏á SpotLight ‡πÉ‡∏´‡πâ credits
            const spotLight = new THREE.SpotLight(0xffffff, 5);
            spotLight.castShadow = true;
            spotLight.position.set(-2, 1, 0);

            // ‡∏™‡∏£‡πâ‡∏≤‡∏á target ‡πÅ‡∏¢‡∏Å ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÑ‡∏ü‡∏™‡πà‡∏≠‡∏á‡πÑ‡∏õ‡∏ó‡∏µ‡πà‡πÇ‡∏ï‡πä‡∏∞
            const targetObject = new THREE.Object3D();
            targetObject.position.set(-4, 1, 0);
            scene.add(targetObject);

            // ‡∏ï‡∏±‡πâ‡∏á target ‡πÉ‡∏´‡πâ‡πÑ‡∏ü‡∏™‡πà‡∏≠‡∏á‡πÑ‡∏õ‡∏ó‡∏µ‡πà‡∏à‡∏∏‡∏î‡∏ô‡∏±‡πâ‡∏ô
            spotLight.target = targetObject;

            // ‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏∏‡∏ì‡∏™‡∏°‡∏ö‡∏±‡∏ï‡∏¥‡∏Ç‡∏≠‡∏á‡πÅ‡∏™‡∏á
            spotLight.angle = Math.PI / 5;
            spotLight.penumbra = 0.4;
            spotLight.distance = 10;
            spotLight.decay = 2;
            spotLight.visible = true
            scene.add(spotLight);

            // --- Objects (3 ‡∏ä‡∏¥‡πâ‡∏ô / ‡∏™‡∏µ‡∏ï‡πà‡∏≤‡∏á‡∏Å‡∏±‡∏ô / ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡πÑ‡∏ü‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡πÉ‡∏ä‡πâ MeshBasic) ---
            const clickable = [];
            let pickObjPosition = new THREE.Vector3();
            let cameraPosition = new THREE.Vector3(-5, 1, 0);
            function addObj(mesh, pos, name) {
                mesh.position.copy(pos);
                mesh.name = name;
                scene.add(mesh);
                clickable.push(mesh);
                return mesh;
            }
            // const Plane = addObj(
            //     new THREE.Mesh(
            //         plane_geometry,
            //         new THREE.MeshStandardMaterial({ color: 0x110000 })
            //     ),
            //     new THREE.Vector3(0, 0, 0),
            //     "Plane"
            // );
            // const cylinder = addObj(
            //     new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 1, 24), new THREE.MeshBasicMaterial({ color: 0xffbb00 })),
            //     new THREE.Vector3(0, 0.5, -2),
            //     'Cylinder'
            // );
            // cylinder.position.x = lerp(0.0, 2.0, 0.0)
            // --- ‡∏û‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏ï‡πà‡∏≠‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏ (‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏á‡πà‡∏≤‡∏¢ ‡πÜ) ---
            const VIEWS = {
                Cube: { pos: new THREE.Vector3(3, 1, 0), tar: new THREE.Vector3(5, 0.5, 0) },
                PBR_Material: { pos: new THREE.Vector3(2, 0.5, 1), tar: new THREE.Vector3(2, 0.5, 2) },
                nextPBR: { pos: new THREE.Vector3(0, 0.5, 1), tar: new THREE.Vector3(0, 0.5, 2) },
                backPBR: { pos: new THREE.Vector3(3, 1, 0), tar: new THREE.Vector3(5, 0.8, 0) },
                nextCel: { pos: new THREE.Vector3(-2, 0.5, 1), tar: new THREE.Vector3(-2, 0.5, 2) },
                backCel: { pos: new THREE.Vector3(2, 0.5, 1), tar: new THREE.Vector3(2, 0.5, 2) },
                backVer: { pos: new THREE.Vector3(0, 0.5, 1), tar: new THREE.Vector3(0, 0.5, 2) },
                credits: { pos: new THREE.Vector3(-2.5, 1, 0), tar: new THREE.Vector3(-4, 1, 0) }
            };
            const PBRDialog = document.getElementById("PBRDialog")
            const CelShadingDialog = document.getElementById("CelShadingDialog");
            const VertexShaderDialog = document.getElementById("VertexShaderDialog");
            // --- Raycaster + ‡∏Ñ‡∏•‡∏¥‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡∏•‡∏±‡∏ö‡∏°‡∏∏‡∏° ---
            const raycaster = new THREE.Raycaster();
            const pointer = new THREE.Vector2();

            let isDragging = false;
            let targetMesh = null;
            let prevMouseX = 0, prevMouseY = 0;

            // ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏Ñ‡∏•‡∏¥‡∏Å‡∏•‡∏á
            window.addEventListener('mousedown', (event) => {
                pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
                pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(pointer, camera);
                const intersects = raycaster.intersectObject(dice_mesh);
                const intersects2 = raycaster.intersectObject(map_mesh);

                if (intersects.length > 0) {
                    isDragging = true;
                    targetMesh = dice_mesh;
                    prevMouseX = event.clientX;
                    prevMouseY = event.clientY;
                }
                else if (intersects2.length > 0) {
                    isDragging = true;
                    targetMesh = map_mesh;
                    prevMouseX = event.clientX;
                    prevMouseY = event.clientY;
                }
            });

            // ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Ñ‡∏•‡∏¥‡∏Å‡πÄ‡∏°‡∏≤‡∏™‡πå‡∏•‡∏á ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏´‡∏°‡∏∏‡∏ô‡∏ï‡∏±‡∏ß model ‡∏ó‡∏µ‡πà‡πÇ‡∏ä‡∏ß‡πå‡∏≠‡∏¢‡∏π‡πà
            window.addEventListener('mousedown', (event) => {
                pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
                pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(pointer, camera);
                const intersects = raycaster.intersectObject(dice_mesh);
                const intersects2 = raycaster.intersectObject(map_mesh);

                if (intersects.length > 0) {
                    isDragging = true;
                    targetMesh = dice_mesh;
                    prevMouseX = event.clientX;
                    prevMouseY = event.clientY;
                }
                else if (intersects2.length > 0) {
                    isDragging = true;
                    targetMesh = map_mesh;
                    prevMouseX = event.clientX;
                    prevMouseY = event.clientY;
                }
            });

            // ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏°‡∏≤‡∏™‡πå‡∏•‡∏≤‡∏Å ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏´‡∏°‡∏∏‡∏ô‡∏ï‡∏±‡∏ß model ‡∏ó‡∏µ‡πà‡πÇ‡∏ä‡∏ß‡πå‡∏≠‡∏¢‡∏π‡πà
            window.addEventListener('mousemove', (event) => {
                if (!isDragging || !targetMesh) return;

                const deltaX = event.clientX - prevMouseX;
                const deltaY = event.clientY - prevMouseY;

                // ‡∏´‡∏°‡∏∏‡∏ô‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏ï‡∏≤‡∏°‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏≤‡∏Å‡πÄ‡∏°‡∏≤‡∏™‡πå
                targetMesh.rotation.y += deltaX * 0.01;
                targetMesh.rotation.x += deltaY * -0.01;

                prevMouseX = event.clientX;
                prevMouseY = event.clientY;
            });

            // ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏õ‡∏•‡πà‡∏≠‡∏¢‡πÄ‡∏°‡∏≤‡∏™‡πå ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏´‡∏°‡∏∏‡∏ô‡∏ï‡∏±‡∏ß model ‡∏ó‡∏µ‡πà‡πÇ‡∏ä‡∏ß‡πå‡∏≠‡∏¢‡∏π‡πà
            window.addEventListener('mouseup', () => {
                isDragging = false;
                targetMesh = null;
            });
            function setPointer(e) {
                const r = renderer.domElement.getBoundingClientRect();
                const x = (e.clientX ?? e.touches[0].clientX) - r.left;
                const y = (e.clientY ?? e.touches[0].clientY) - r.top;
                pointer.x = (x / r.width) * 2 - 1;
                pointer.y = -(y / r.height) * 2 + 1;
            }
            let whatGotPick = null
            let hoveredObject = null;
            let stopControlsCamera = false;
            let startCamera = true;
            function onPick(e) {
                if (startCamera) return;
                if (stopControlsCamera) return;
                setPointer(e);
                raycaster.setFromCamera(pointer, camera);

                const objectsToPick = [...clickable];
                if (theMan) objectsToPick.push(theMan);
                if (nextBtnPBR) objectsToPick.push(nextBtnPBR);
                if (backBtnPBR) objectsToPick.push(backBtnPBR);
                if (nextBtnCel) objectsToPick.push(nextBtnCel);
                if (backBtnCel) objectsToPick.push(backBtnCel);
                if (backBtnVertex) objectsToPick.push(backBtnVertex);
                if (goToThemanCredit) objectsToPick.push(goToThemanCredit);
                if (goToDiceCredit) objectsToPick.push(goToDiceCredit);
                if (goToBaseCredit) objectsToPick.push(goToBaseCredit);
                if (goToHeightmapCredit) objectsToPick.push(goToHeightmapCredit);
                const hit = raycaster.intersectObjects(objectsToPick, true)[0];
                if (!hit) return;
                // ‡∏ñ‡πâ‡∏≤ hit ‡πÄ‡∏õ‡πá‡∏ô child ‡∏Ç‡∏≠‡∏á theMan ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ root ‡∏Ç‡∏≠‡∏á theMan
                const view = VIEWS[hit.object.name];
                whatGotPick = hit.object.name;
                const pickedType = hit.object.userData.parentType;
                if (whatGotPick === "Cube" && document.getElementById("welcome").textContent == "‡∏Å‡∏î‡∏ó‡∏µ‡πà‡∏Å‡∏•‡πà‡∏≠‡∏á") {
                    document.getElementById("welcome").textContent = "‡πÄ‡∏¢‡∏µ‡πà‡∏¢‡∏°!"
                    setTimeout(() => {
                        requestAnimationFrame(() => {
                            document.getElementById("welcome").classList.add("slideOut")
                        })
                    }, 1000);
                }
                if (pickedType === "nextBtnPBR") {
                    PBRDialog.style.display = "none"
                    CelShadingDialog.style.display = "flex"
                    CelShadingDialog.classList.remove("slideInDialog")
                    requestAnimationFrame(() => {
                        CelShadingDialog.classList.add("slideInDialog")
                    })
                    cameraPosition = VIEWS.nextPBR.pos.clone();
                    pickObjPosition = VIEWS.nextPBR.tar.clone();
                    setTimeout(() => {
                        spotLight2.visible = true
                    }, 1000)
                }
                else if (pickedType === "backBtnPBR") {
                    PBRDialog.style.display = "none"
                    fadeOutModel(nextBtnPBR, 500)
                    fadeOutModel(backBtnPBR, 500)
                    fadeOutModel(nextBtnCel, 500)
                    fadeOutModel(backBtnCel, 500)
                    fadeOutModel(backBtnVertex, 500)
                    cameraPosition = VIEWS.backPBR.pos.clone();
                    pickObjPosition = VIEWS.backPBR.tar.clone();
                    controls.enabled = "true"
                    ptLight.visible = "true"
                    setTimeout(() => {
                        spotLight1.visible = false
                        spotLight2.visible = false
                        spotLight3.visible = false
                    }, 700)
                }
                else if (pickedType === "nextBtnCel") {
                    CelShadingDialog.style.display = "none"
                    VertexShaderDialog.style.display = "flex"
                    VertexShaderDialog.classList.remove("slideInDialog")
                    requestAnimationFrame(() => {
                        VertexShaderDialog.classList.add("slideInDialog")
                    })
                    cameraPosition = VIEWS.nextCel.pos.clone();
                    pickObjPosition = VIEWS.nextCel.tar.clone();
                    setTimeout(() => {
                        spotLight3.visible = true
                    }, 1000)
                }
                else if (pickedType === "backBtnCel") {
                    CelShadingDialog.style.display = "none"
                    PBRDialog.style.display = "flex"
                    PBRDialog.classList.remove("slideInDialog")
                    requestAnimationFrame(() => {
                        PBRDialog.classList.add("slideInDialog")
                    })
                    cameraPosition = VIEWS.backCel.pos.clone();
                    pickObjPosition = VIEWS.backCel.tar.clone();
                }
                else if (pickedType === "backBtnVertex") {
                    VertexShaderDialog.style.display = "none"
                    CelShadingDialog.style.display = "flex"
                    CelShadingDialog.classList.remove("slideInDialog")
                    requestAnimationFrame(() => {
                        CelShadingDialog.classList.add("slideInDialog")
                    })
                    cameraPosition = VIEWS.backVer.pos.clone();
                    pickObjPosition = VIEWS.backVer.tar.clone();
                }
                else if (pickedType === "goToThemanCredit") {
                    window.open("https://sketchfab.com/3d-models/man-sitting-d8ca320050c6494581c34292356a280b")
                }
                else if (pickedType === "goToDiceCredit") {
                    window.open("https://sketchfab.com/3d-models/dice-roblox-3d-model-81c71c205ff244f9bfc85aaa31089b7c")
                }
                else if (pickedType === "goToBaseCredit") {
                    window.open("https://sketchfab.com/3d-models/vr-room-light-baked-d3d10773cfb34aec975d46db538ff59e")
                }
                else if (pickedType === "goToHeightmapCredit") {
                    window.open("https://upload.wikimedia.org/wikipedia/commons/8/8b/Thailand_location_relief_map.svg")
                }
                cameraPosition = view.pos.clone();
                pickObjPosition = view.tar.clone();
                if (!view) return;
                showDialog()
                controls.update();
            }
            function onHover(e) {
                setPointer(e);
                raycaster.setFromCamera(pointer, camera);

                const objectsToCheck = [];
                if (theMan) objectsToCheck.push(theMan);
                if (nextBtnPBR) objectsToCheck.push(nextBtnPBR);
                if (backBtnPBR) objectsToCheck.push(backBtnPBR);
                if (nextBtnCel) objectsToCheck.push(nextBtnCel);
                if (backBtnCel) objectsToCheck.push(backBtnCel);
                if (backBtnVertex) objectsToCheck.push(backBtnVertex);
                if (goToThemanCredit) objectsToCheck.push(goToThemanCredit);
                if (goToDiceCredit) objectsToCheck.push(goToDiceCredit);
                if (goToBaseCredit) objectsToCheck.push(goToBaseCredit);
                if (goToHeightmapCredit) objectsToCheck.push(goToHeightmapCredit);
                const hit = raycaster.intersectObjects(objectsToCheck, true)[0];

                if (hit) {
                    const mesh = hit.object;
                    if (hoveredObject !== mesh) {
                        // ‡∏Ñ‡∏∑‡∏ô‡∏™‡∏µ‡πÄ‡∏î‡∏¥‡∏°‡∏ñ‡πâ‡∏≤‡∏°‡∏µ object ‡πÄ‡∏î‡∏¥‡∏°
                        if (hoveredObject) {
                            hoveredObject.material.emissive?.setHex(hoveredObject.currentHex);
                        }
                        // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å object ‡πÉ‡∏´‡∏°‡πà
                        hoveredObject = mesh;
                        hoveredObject.currentHex = hoveredObject.material.emissive?.getHex() ?? 0x000000;
                        hoveredObject.material.emissive?.setHex(0xffff00); // ‡∏™‡∏µ‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏á highlight
                    }
                } else {
                    // ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£ hover
                    if (hoveredObject) {
                        hoveredObject.material.emissive?.setHex(hoveredObject.currentHex);
                        hoveredObject = null;
                    }
                }
            }

            renderer.domElement.addEventListener('click', onPick);
            renderer.domElement.addEventListener('mousemove', onHover);
            renderer.domElement.addEventListener('touchend', (e) => { onPick(e); }, { passive: true });

            // --- Resize ---
            addEventListener('resize', () => {
                camera.aspect = innerWidth / innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(innerWidth, innerHeight);
            });

            function lerp(a, b, t) {
                return a + (b - a) * t;   // t ‡πÉ‡∏ô [0..1]
            }
            const theManDialog = document.getElementById('theManDialog')
            const creditDialog = document.getElementById("creditDialog")
            let t = null
            let cylinderTarget = new THREE.Vector3();
            // --- Loop ---
            function loop() {
                if (startCamera) {
                    const welcome = document.getElementById("welcome")
                    if (camera.position.distanceTo(new THREE.Vector3(-3, 2, 0)) < 0.05) {
                        welcome.classList.add("slideIn");
                        // fadeInModel(myInfo, 1000);
                    }

                    cameraPosition = new THREE.Vector3(3, 1, 0);
                    pickObjPosition = new THREE.Vector3(5, 0.5, 0);
                    controls.target.set(5, 0.8, 0);
                    controls.target.lerp(pickObjPosition, 0.005) //0.005
                    camera.position.lerp(cameraPosition, 0.005) //0.005
                    if (camera.position.distanceTo(new THREE.Vector3(3, 1, 0)) < 0.05) {
                        startCamera = false;
                        welcome.style.color = "gold"
                        welcome.textContent = "‡∏Å‡∏î‡∏ó‡∏µ‡πà‡∏Å‡∏•‡πà‡∏≠‡∏á"
                        welcome.classList.remove("slideIn");
                        // fadeOutModel(myPic, 1000);
                        // fadeOutModel(myInfo, 1000);
                    }
                }
                else if (!stopControlsCamera) {
                    controls.target.lerp(pickObjPosition, 0.01)
                    camera.position.lerp(cameraPosition, 0.01)
                }
                cube.rotation.x += 0.01;
                cube.rotation.y += 0.015;
                uniforms.uTime.value = performance.now() / 1000; // ‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡πÑ‡∏î‡πâ‡∏î‡πâ‡∏ß‡∏¢‡∏Å‡∏≤‡∏£‡∏Ñ‡∏π‡∏ì factor
                if (spotLight2) {
                    uniforms.uLightPos.value.copy(spotLight2.position);
                }
                //animation ‡∏Ç‡∏≠‡∏á the man
                const delta = clock.getDelta();
                if (mixer) mixer.update(delta);

                uniforms.uCameraPos.value.copy(camera.position);
                mapUniforms.uTime.value += 0.05;
                TWEEN.update();
                controls.update();
                renderer.render(scene, camera);
                requestAnimationFrame(loop);
            }
            loop();
            document.addEventListener("keydown", (e) => {
                // const status = document.getElementById("status")
                console.log("Key pressed:", e.code);
                if (e.code === "Space") {
                    stopControlsCamera = !stopControlsCamera;
                    // if (!stopControlsCamera) {
                    //     status.textContent = "Lock: on"
                    // } else {
                    //     status.textContent = "Lock: off"
                    // }
                }
                else if (e.code === "Escape") {
                    theManDialog.style.display = "none"
                    PBRDialog.style.display = "none"
                    CelShadingDialog.style.display = "none"
                    VertexShaderDialog.style.display = "none"
                    creditDialog.style.display = "none"
                    controls.enabled = true;
                    ptLight.visible = true;
                    spotLight1.visible = false;
                    spotLight2.visible = false;
                    spotLight3.visible = false;
                    fadeOutModel(nextBtnPBR, 500)
                    fadeOutModel(backBtnPBR, 500)
                    fadeOutModel(nextBtnCel, 500)
                    fadeOutModel(backBtnCel, 500)
                    fadeOutModel(backBtnVertex, 500)
                    if (stopControlsCamera) {
                        camera.position.set(3, 1, 0)
                    }
                    cameraPosition = new THREE.Vector3(3, 1, 0);
                    controls.target.set(5, 0.8, 0);
                    pickObjPosition = new THREE.Vector3(5, 0.5, 0);
                }
            })
            function showDialog() {
                theManDialog.style.display = "none"
                theManDialog.classList.remove("slideInDialog")
                if (whatGotPick.toLowerCase().includes('cube')) {
                    theManDialog.style.display = "flex"
                    requestAnimationFrame(() => {
                        theManDialog.classList.add("slideInDialog")
                    })
                }
            }
            let timeOut = null
            window.answer = function (question) {
                if (timeOut != null) return;
                const ansQuestion = document.getElementById("ansQuestion")
                const myname = document.getElementById("myname")
                const myage = document.getElementById("myage")
                const credits = document.getElementById("credits")
                const descMySelf = document.getElementById("descMySelf")
                const mywork = document.getElementById("mywork")
                const descMySelf_q_1 = document.getElementById("descMySelf_q_1")
                if (question === "myname") {
                    myname.classList.remove("slideInDialog")
                    requestAnimationFrame(() => {
                        myname.classList.add("slideOut")
                    })
                    setTimeout(() => {
                        ansQuestion.textContent = "."
                        myname.style.display = "none"
                    }, 500)
                    setTimeout(() => {
                        ansQuestion.textContent = ".."
                    }, 1000)
                    setTimeout(() => {
                        ansQuestion.textContent = "..."
                    }, 1500)
                    setTimeout(() => {
                        ansQuestion.textContent = "‡∏ä‡∏∑‡πà‡∏≠‡∏Å‡∏§‡∏ï‡∏à‡πâ‡∏≤"
                        timeOut = null
                    }, 2000)
                    setTimeout(() => {
                        ansQuestion.textContent = "."
                    }, 3500)
                    setTimeout(() => {
                        ansQuestion.textContent = ".."
                    }, 4000)
                    setTimeout(() => {
                        ansQuestion.textContent = "..."
                    }, 4500)
                    setTimeout(() => {
                        ansQuestion.textContent = "‡∏°‡∏µ‡∏≠‡∏∞‡πÑ‡∏£‡∏≠‡∏¢‡∏≤‡∏Å‡∏à‡∏∞‡∏ñ‡∏≤‡∏°‡∏≠‡∏µ‡∏Å‡∏°‡∏±‡πâ‡∏¢‡∏ô‡∏∞?"
                        timeOut = null
                    }, 5000)
                    timeOut = setTimeout(() => {
                        descMySelf.style.display = "flex"
                        myage.style.display = "flex"
                        credits.style.display = "flex"
                        mywork.style.display = "flex"
                        descMySelf.classList.add("slideInDialog")
                        myage.classList.add("slideInDialog")
                        credits.classList.add("slideInDialog")
                        mywork.classList.add("slideInDialog")
                        timeOut = null
                    }, 5500)
                }
                else if (question === "myage") {
                    descMySelf.classList.remove("slideInDialog")
                    myage.classList.remove("slideInDialog")
                    credits.classList.remove("slideInDialog")
                    mywork.classList.remove("slideInDialog")
                    requestAnimationFrame(() => {
                        myage.classList.add("slideOut")
                    })
                    setTimeout(() => {
                        ansQuestion.textContent = "."
                        descMySelf.style.display = "none"
                        credits.style.display = "none"
                        myage.style.display = "none"
                        mywork.style.display = "none"
                    }, 500)
                    setTimeout(() => {
                        ansQuestion.textContent = ".."
                    }, 1000)
                    setTimeout(() => {
                        ansQuestion.textContent = "..."
                    }, 1500)
                    setTimeout(() => {
                        ansQuestion.textContent = "21 ‡∏à‡πâ‡∏≤"
                    }, 2000)
                    setTimeout(() => {
                        ansQuestion.textContent = "."
                    }, 3500)
                    setTimeout(() => {
                        ansQuestion.textContent = ".."
                    }, 4000)
                    setTimeout(() => {
                        ansQuestion.textContent = "..."
                    }, 4500)
                    setTimeout(() => {
                        ansQuestion.textContent = "‡∏°‡∏µ‡∏≠‡∏∞‡πÑ‡∏£‡∏≠‡∏¢‡∏≤‡∏Å‡∏à‡∏∞‡∏ñ‡∏≤‡∏°‡∏≠‡∏µ‡∏Å‡∏°‡∏±‡πâ‡∏¢‡∏ô‡∏∞?"
                        timeOut = null
                    }, 5000)
                    timeOut = setTimeout(() => {
                        myage.classList.remove("slideOut")
                        descMySelf.style.display = "flex"
                        myage.style.display = "flex"
                        credits.style.display = "flex"
                        mywork.style.display = "flex"
                        requestAnimationFrame(() => {
                            myage.classList.add("slideInDialog")
                        })
                        mywork.classList.add("slideInDialog")
                        descMySelf.classList.add("slideInDialog")
                        credits.classList.add("slideInDialog")
                        timeOut = null
                    }, 5500)
                }
                else if (question === "descMySelf") {
                    descMySelf.classList.remove("slideInDialog")
                    myage.classList.remove("slideInDialog")
                    credits.classList.remove("slideInDialog")
                    mywork.classList.remove("slideInDialog")
                    requestAnimationFrame(() => {
                        descMySelf.classList.add("slideOut")
                    })

                    setTimeout(() => {
                        descMySelf.style.display = "none"
                        credits.style.display = "none"
                        myage.style.display = "none"
                        mywork.style.display = "none"
                        ansQuestion.textContent = "."
                    }, 500)
                    setTimeout(() => {
                        ansQuestion.textContent = ".."
                    }, 1000)
                    setTimeout(() => {
                        ansQuestion.textContent = "..."
                    }, 1500)
                    setTimeout(() => {
                        ansQuestion.textContent = "‡πÑ‡∏î‡πâ‡∏™‡∏¥!"
                    }, 2000)
                    setTimeout(() => {
                        ansQuestion.textContent = ""
                        pickObjPosition = new THREE.Vector3(5, 1, 0);
                        controls.target.lerp(pickObjPosition, 0.005)
                        fadeInModel(myInfo, 1000);
                        fadeInModel(myPic, 1000);
                    }, 2500)
                    setTimeout(() => {
                        pickObjPosition = new THREE.Vector3(5, 0.5, 0);
                        controls.target.lerp(pickObjPosition, 0.005)
                    }, 7000)
                    setTimeout(() => {
                        ansQuestion.textContent = "."
                    }, 8000)
                    setTimeout(() => {
                        ansQuestion.textContent = ".."
                    }, 8500)
                    setTimeout(() => {
                        ansQuestion.textContent = "..."
                    }, 9000)
                    setTimeout(() => {
                        ansQuestion.textContent = "‡πÄ‡∏õ‡πá‡∏ô‡πÑ‡∏á‡∏ö‡πâ‡∏≤‡∏á?"
                    }, 9500)
                    timeOut = setTimeout(() => {
                        descMySelf.classList.remove("slideOut")
                        descMySelf_q_1.style.display = "flex"
                        descMySelf_q_1.classList.add("slideInDialog")
                        timeOut = null
                    }, 10000)
                }
                else if (question === "descMySelf_q_1") {
                    requestAnimationFrame(() => {
                        descMySelf_q_1.classList.add("slideOut")
                    })
                    setTimeout(() => {
                        ansQuestion.textContent = "."
                        descMySelf_q_1.style.display = "none"
                    }, 500)
                    setTimeout(() => {
                        ansQuestion.textContent = ".."
                    }, 1000)
                    setTimeout(() => {
                        ansQuestion.textContent = "..."
                    }, 1500)
                    setTimeout(() => {
                        ansQuestion.textContent = "‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß ‡∏≠‡∏¥‡∏≠‡∏¥"
                    }, 2000)
                    setTimeout(() => {
                        ansQuestion.textContent = "‡∏°‡∏µ‡∏≠‡∏∞‡πÑ‡∏£‡∏≠‡∏¢‡∏≤‡∏Å‡∏à‡∏∞‡∏ñ‡∏≤‡∏°‡∏≠‡∏µ‡∏Å‡∏°‡∏±‡πâ‡∏¢‡∏ô‡∏∞?"
                    }, 3000)
                    timeOut = setTimeout(() => {
                        descMySelf.style.display = "flex"
                        myage.style.display = "flex"
                        credits.style.display = "flex"
                        mywork.style.display = "flex"

                        descMySelf.classList.add("slideInDialog")
                        myage.classList.add("slideInDialog")
                        mywork.classList.add("slideInDialog")
                        credits.classList.add("slideInDialog")
                        timeOut = null
                    }, 3500)
                }
                else if (question === "mywork") {
                    controls.enabled = false;
                    theManDialog.style.display = "none"
                    PBRDialog.classList.remove("slideInDialog")
                    setTimeout(() => {
                        ptLight.visible = false;
                    }, 1000)
                    setTimeout(() => {
                        PBRDialog.style.display = "flex"
                        requestAnimationFrame(() => {
                            PBRDialog.classList.add("slideInDialog")
                            spotLight1.visible = true;
                        })
                    }, 2000);
                    const view = VIEWS["PBR_Material"];
                    if (view) {
                        cameraPosition.copy(view.pos);
                        pickObjPosition.copy(view.tar);
                    }
                    fadeInModel(nextBtnPBR, 2000);
                    fadeInModel(backBtnPBR, 2000);
                    fadeInModel(nextBtnCel, 2000);
                    fadeInModel(backBtnCel, 2000);
                    fadeInModel(backBtnVertex, 2000);
                }
                else if (question === "credits") {
                    controls.enabled = false;
                    theManDialog.style.display = "none"
                    setTimeout(() => {
                        ptLight.visible = false;
                        creditDialog.style.display = "flex"
                    }, 1000)
                    const view = VIEWS["credits"];
                    if (view) {
                        cameraPosition.copy(view.pos);
                        pickObjPosition.copy(view.tar);
                    }
                }
            }
            function fadeInModel(model, duration = 1000) {
                if (!model) return;
                model.traverse(node => {
                    if (node.isMesh) {
                        new TWEEN.Tween({ opacity: node.material.opacity })
                            .to({ opacity: 1 }, duration)
                            .onUpdate(({ opacity }) => node.material.opacity = opacity)
                            .start();
                    }
                });
            }
            function fadeOutModel(model, duration = 1000) {
                if (!model) return;
                model.traverse(node => {
                    if (node.isMesh) {
                        new TWEEN.Tween({ opacity: node.material.opacity })
                            .to({ opacity: 0 }, duration)
                            .onUpdate(({ opacity }) => node.material.opacity = opacity)
                            .start();
                    }
                });
            }
        })();
    </script>
</body>

</html>